/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * V3.0
 */

#include <utils/Log.h>
#include "sensor.h"
#include "jpeg_exif_header.h"
#include "sensor_drv_u.h"
#include "sensor_raw.h"
#include "isp_param_file_update.h"
#include "sensor_hi553_denoise.c"

#if defined(CONFIG_CAMERA_ISP_VERSION_V3) || defined(CONFIG_CAMERA_ISP_VERSION_V4)
//#include "sensor_hi553_raw_param_v3.c"
#include "hi553_parameters/sensor_hi553_raw_param_main.c"
#else
#include "sensor_hi553_raw_param.c"
#endif

#ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
#include "../af_dw9714.h"
#endif

#define SENSOR_NAME			    "hi553"
#define I2C_SLAVE_ADDR_R	0x41    /* 8bit slave address*/
#define I2C_SLAVE_ADDR_W	0x40    /* 8bit slave address*/

#define hi553_PID_ADDR			0x0f16
#define hi553_PID_VALUE			0x553
#define hi553_VER_ADDR			0x0f16
#define hi553_VER_VALUE			0x553

/* sensor parameters begin */
/* effective sensor output image size */
#define SNAPSHOT_WIDTH			2592
#define SNAPSHOT_HEIGHT			1944
#define PREVIEW_WIDTH			1296
#define PREVIEW_HEIGHT			972

/*Mipi output*/
#define LANE_NUM			2
#define RAW_BITS				10

#define SNAPSHOT_MIPI_PER_LANE_BPS	880
#define PREVIEW_MIPI_PER_LANE_BPS	440

/*line time unit: 0.1us*/
#define SNAPSHOT_LINE_TIME		160
#define PREVIEW_LINE_TIME		160

/* frame length*/
#define SNAPSHOT_FRAME_LENGTH		1980
#define PREVIEW_FRAME_LENGTH		1980

/* please ref your spec */
#define FRAME_OFFSET			4
#define SENSOR_MAX_GAIN			0x100
#define SENSOR_BASE_GAIN		0x10
#define SENSOR_MIN_SHUTTER		6

/* please ref your spec
 * 1 : average binning
 * 2 : sum-average binning
 * 4 : sum binning
 */
#define BINNING_FACTOR			1

/* please ref spec
 * 1: sensor auto caculate
 * 0: driver caculate
 */
#define SUPPORT_AUTO_FRAME_LENGTH	0
/* sensor parameters end */

/* isp parameters, please don't change it*/
#if defined(CONFIG_CAMERA_ISP_VERSION_V3) || defined(CONFIG_CAMERA_ISP_VERSION_V4)
#define ISP_BASE_GAIN			0x80
#else
#define ISP_BASE_GAIN			0x10
#endif
/* please don't change it */
#define EX_MCLK				24

struct hdr_info_t {
	cmr_uint capture_max_shutter;
	cmr_uint capture_shutter;
	cmr_uint capture_gain;
};

struct sensor_ev_info_t {
	uint16_t preview_shutter;
	uint16_t preview_gain;
};

/*==============================================================================
 * Description:
 * global variable
 *============================================================================*/
static struct hdr_info_t s_hdr_info;
static cmr_uint s_current_default_frame_length;
struct sensor_ev_info_t s_sensor_ev_info;

#define FEATURE_OTP    /*OTP function switch*/

#ifdef FEATURE_OTP
#define MODULE_ID_NULL			0x0000
#define MODULE_ID_hi553_sunny		0x0008    //xxx: sensor P/N;  yyy: module vendor
#define MODULE_ID_END			0xFFFF
#define LSC_PARAM_QTY 240

struct otp_info_t {
	uint16_t flag;
	uint16_t module_id;
	uint16_t lens_id;
	uint16_t vcm_id;
	uint16_t vcm_driver_id;
	uint16_t year;
	uint16_t month;
	uint16_t day;
	uint16_t rg_ratio_current;
	uint16_t bg_ratio_current;
	uint16_t rg_ratio_typical;
	uint16_t bg_ratio_typical;
	uint16_t r_current;
	uint16_t g_current;
	uint16_t b_current;
	uint16_t r_typical;
	uint16_t g_typical;
	uint16_t b_typical;
	uint16_t vcm_dac_start;
	uint16_t vcm_dac_inifity;
	uint16_t vcm_dac_macro;
	uint16_t lsc_param[LSC_PARAM_QTY];
};


#include "sensor_hi553_sunny_otp.c"

struct raw_param_info_tab s_hi553_raw_param_tab[] = {
	{MODULE_ID_hi553_sunny, &s_hi553_mipi_raw_info, hi553_sunny_identify_otp, hi553_sunny_update_otp},
	{MODULE_ID_END, PNULL, PNULL, PNULL}
};

#endif

static SENSOR_IOCTL_FUNC_TAB_T s_hi553_ioctl_func_tab;
struct sensor_raw_info *s_hi553_mipi_raw_info_ptr = &s_hi553_mipi_raw_info;

static const SENSOR_REG_T hi553_init_setting[] = {
//Sensor Information////////////////////////////
//Sensor	  : Hi-553
//Date		  : 2015-09-18
//Customer        : CN01
//Image size	  : 2592x1944
//MCLK		  : 24MHz
//MIPI speed(Mbps): 880Mbps x 2Lane
//Frame Length	  : 2083
//Line Length 	  : 2816
//Max Fps	  : 30.0fps
//Pixel order 	  : Green 1st (=GB)
//X/Y-flip	  : X-flip
//BLC offset	  : 64code
////////////////////////////////////////////////

{0x0e00, 0x0102},
{0x0e02, 0x0102},
{0x0e0c, 0x0100},
{0x2000, 0x7400},
{0x2002, 0x1303},
{0x2004, 0x7006},
{0x2006, 0x1303},
{0x2008, 0x0bd2},
{0x200a, 0x5001},
{0x200c, 0x7000},
{0x200e, 0x16c6},
{0x2010, 0x0044},
{0x2012, 0x0307},
{0x2014, 0x0008},
{0x2016, 0x00c4},
{0x2018, 0x0009},
{0x201a, 0x207e},
{0x201c, 0x7001},
{0x201e, 0x0fd0},
{0x2020, 0x00d1},
{0x2022, 0x00a1},
{0x2024, 0x00c9},
{0x2026, 0x030b},
{0x2028, 0x7008},
{0x202a, 0x81c0},
{0x202c, 0x01d7},
{0x202e, 0x0022},
{0x2030, 0x0016},
{0x2032, 0x7006},
{0x2034, 0x0fe2},
{0x2036, 0x0016},
{0x2038, 0x20d0},
{0x203a, 0x15c8},
{0x203c, 0x0007},
{0x203e, 0x0000},
{0x2040, 0x0540},
{0x2042, 0x0007},
{0x2044, 0x0008},
{0x2046, 0x0ec5},
{0x2048, 0x00cc},
{0x204a, 0x00c5},
{0x204c, 0x00cc},
{0x204e, 0x04d7},
{0x2050, 0x18e2},
{0x2052, 0x0016},
{0x2054, 0x70e1},
{0x2056, 0x18e2},
{0x2058, 0x16d6},
{0x205a, 0x0022},
{0x205c, 0x8251},
{0x205e, 0x2128},
{0x2060, 0x2100},
{0x2062, 0x702f},
{0x2064, 0x2f06},
{0x2066, 0x2300},
{0x2068, 0x7800},
{0x206a, 0x7400},
{0x206c, 0x1303},
{0x206e, 0x7006},
{0x2070, 0x1303},
{0x2072, 0x0bd2},
{0x2074, 0x5061},
{0x2076, 0x7000},
{0x2078, 0x16c6},
{0x207a, 0x0044},
{0x207c, 0x0307},
{0x207e, 0x0008},
{0x2080, 0x00c4},
{0x2082, 0x0009},
{0x2084, 0x207e},
{0x2086, 0x7001},
{0x2088, 0x0fd0},
{0x208a, 0x00d1},
{0x208c, 0x00a1},
{0x208e, 0x00c9},
{0x2090, 0x030b},
{0x2092, 0x7008},
{0x2094, 0x84c0},
{0x2096, 0x01d7},
{0x2098, 0x0022},
{0x209a, 0x0016},
{0x209c, 0x7006},
{0x209e, 0x0fe2},
{0x20a0, 0x0016},
{0x20a2, 0x20d0},
{0x20a4, 0x15c8},
{0x20a6, 0x0007},
{0x20a8, 0x0000},
{0x20aa, 0x0540},
{0x20ac, 0x0007},
{0x20ae, 0x0008},
{0x20b0, 0x0ec5},
{0x20b2, 0x00cc},
{0x20b4, 0x00c5},
{0x20b6, 0x00cc},
{0x20b8, 0x04d7},
{0x20ba, 0x18e2},
{0x20bc, 0x0016},
{0x20be, 0x70e1},
{0x20c0, 0x18e2},
{0x20c2, 0x16d6},
{0x20c4, 0x0022},
{0x20c6, 0x8551},
{0x20c8, 0x2128},
{0x20ca, 0x2100},
{0x20cc, 0x2006},
{0x20ce, 0x2300},
{0x20d0, 0x7800},
{0x20d2, 0x7400},
{0x20d4, 0x0005},
{0x20d6, 0x7002},
{0x20d8, 0x1303},
{0x20da, 0x00c5},
{0x20dc, 0x7002},
{0x20de, 0x1303},
{0x20e0, 0x0bd2},
{0x20e2, 0x50c1},
{0x20e4, 0x7000},
{0x20e6, 0x16c6},
{0x20e8, 0x0044},
{0x20ea, 0x0307},
{0x20ec, 0x0008},
{0x20ee, 0x00c4},
{0x20f0, 0x0009},
{0x20f2, 0x207e},
{0x20f4, 0x7001},
{0x20f6, 0x0fd0},
{0x20f8, 0x00d1},
{0x20fa, 0x00a1},
{0x20fc, 0x00c9},
{0x20fe, 0x030b},
{0x2100, 0x7008},
{0x2102, 0x87c0},
{0x2104, 0x01d7},
{0x2106, 0x0022},
{0x2108, 0x0016},
{0x210a, 0x08a2},
{0x210c, 0x0016},
{0x210e, 0x20d0},
{0x2110, 0x15c8},
{0x2112, 0x0007},
{0x2114, 0x0000},
{0x2116, 0x0540},
{0x2118, 0x0007},
{0x211a, 0x0008},
{0x211c, 0x0d45},
{0x211e, 0x00cc},
{0x2120, 0x00c5},
{0x2122, 0x00cc},
{0x2124, 0x04d7},
{0x2126, 0x18e2},
{0x2128, 0x0016},
{0x212a, 0x706f},
{0x212c, 0x18e2},
{0x212e, 0x16d6},
{0x2130, 0x0022},
{0x2132, 0x8857},
{0x2134, 0x2128},
{0x2136, 0x2100},
{0x2138, 0x7800},
{0x213a, 0x3100},
{0x213c, 0x01c6},
{0x213e, 0x01c4},
{0x2140, 0x01c0},
{0x2142, 0x01c6},
{0x2144, 0x2700},
{0x2146, 0x7007},
{0x2148, 0x3f00},
{0x214a, 0x7800},
{0x214c, 0x4031},
{0x214e, 0x83ce},
{0x2150, 0x4346},
{0x2152, 0x40f2},
{0x2154, 0x0006},
{0x2156, 0x81fe},
{0x2158, 0x40f2},
{0x215a, 0x0042},
{0x215c, 0x81ff},
{0x215e, 0x40f2},
{0x2160, 0xff84},
{0x2162, 0x8200},
{0x2164, 0x43c2},
{0x2166, 0x8201},
{0x2168, 0x40b2},
{0x216a, 0x0230},
{0x216c, 0x8030},
{0x216e, 0x40b2},
{0x2170, 0x0032},
{0x2172, 0x8032},
{0x2174, 0x40b2},
{0x2176, 0x01e0},
{0x2178, 0x81d2},
{0x217a, 0x40b2},
{0x217c, 0x03c0},
{0x217e, 0x81d4},
{0x2180, 0x40b2},
{0x2182, 0x05a0},
{0x2184, 0x81d6},
{0x2186, 0x40b2},
{0x2188, 0x0281},
{0x218a, 0x81d8},
{0x218c, 0x40b2},
{0x218e, 0x02c0},
{0x2190, 0x81da},
{0x2192, 0x40b2},
{0x2194, 0x0064},
{0x2196, 0x81e6},
{0x2198, 0x93d2},
{0x219a, 0x003d},
{0x219c, 0x2002},
{0x219e, 0x4030},
{0x21a0, 0xf91e},
{0x21a2, 0x0900},
{0x21a4, 0x7312},
{0x21a6, 0x43d2},
{0x21a8, 0x003d},
{0x21aa, 0x40b2},
{0x21ac, 0x9887},
{0x21ae, 0x0b82},
{0x21b0, 0x40b2},
{0x21b2, 0xc540},
{0x21b4, 0x0b84},
{0x21b6, 0x40b2},
{0x21b8, 0xb540},
{0x21ba, 0x0b86},
{0x21bc, 0x40b2},
{0x21be, 0x0085},
{0x21c0, 0x0b88},
{0x21c2, 0x40b2},
{0x21c4, 0xd304},
{0x21c6, 0x0b8a},
{0x21c8, 0x40b2},
{0x21ca, 0x0420},
{0x21cc, 0x0b8c},
{0x21ce, 0x40b2},
{0x21d0, 0xc200},
{0x21d2, 0x0b8e},
{0x21d4, 0x4392},
{0x21d6, 0x0ba6},
{0x21d8, 0x43d2},
{0x21da, 0x01a0},
{0x21dc, 0x40f2},
{0x21de, 0x0003},
{0x21e0, 0x01a2},
{0x21e2, 0x43d2},
{0x21e4, 0x019d},
{0x21e6, 0x43d2},
{0x21e8, 0x0f82},
{0x21ea, 0x0cff},
{0x21ec, 0x0cff},
{0x21ee, 0x0cff},
{0x21f0, 0x0cff},
{0x21f2, 0x0cff},
{0x21f4, 0x0cff},
{0x21f6, 0x0c32},
{0x21f8, 0x40f2},
{0x21fa, 0x000e},
{0x21fc, 0x0f90},
{0x21fe, 0x4392},
{0x2200, 0x7326},
{0x2202, 0x90f2},
{0x2204, 0x0010},
{0x2206, 0x00bf},
{0x2208, 0x2002},
{0x220a, 0x4030},
{0x220c, 0xf772},
{0x220e, 0x403b},
{0x2210, 0x7f10},
{0x2212, 0x439b},
{0x2214, 0x0000},
{0x2216, 0x403f},
{0x2218, 0xf13a},
{0x221a, 0x12b0},
{0x221c, 0xe12a},
{0x221e, 0x438b},
{0x2220, 0x0000},
{0x2222, 0x4392},
{0x2224, 0x81de},
{0x2226, 0x40b2},
{0x2228, 0x02bc},
{0x222a, 0x731e},
{0x222c, 0x43a2},
{0x222e, 0x81dc},
{0x2230, 0xb3e2},
{0x2232, 0x00b4},
{0x2234, 0x2402},
{0x2236, 0x4392},
{0x2238, 0x81dc},
{0x223a, 0x4325},
{0x223c, 0xb3d2},
{0x223e, 0x00b4},
{0x2240, 0x2002},
{0x2242, 0x4030},
{0x2244, 0xf762},
{0x2246, 0x4305},
{0x2248, 0x12b0},
{0x224a, 0xe16a},
{0x224c, 0x40b2},
{0x224e, 0x012c},
{0x2250, 0x8036},
{0x2252, 0x40b2},
{0x2254, 0x0030},
{0x2256, 0x8034},
{0x2258, 0x12b0},
{0x225a, 0xe238},
{0x225c, 0x4382},
{0x225e, 0x81e4},
{0x2260, 0x40b2},
{0x2262, 0x0005},
{0x2264, 0x7320},
{0x2266, 0x4392},
{0x2268, 0x7326},
{0x226a, 0x425f},
{0x226c, 0x00be},
{0x226e, 0xf07f},
{0x2270, 0x0010},
{0x2272, 0x4f0e},
{0x2274, 0xf03e},
{0x2276, 0x0010},
{0x2278, 0x4e82},
{0x227a, 0x81e2},
{0x227c, 0x425f},
{0x227e, 0x008c},
{0x2280, 0x4fc2},
{0x2282, 0x81e0},
{0x2284, 0x43c2},
{0x2286, 0x81e1},
{0x2288, 0x425f},
{0x228a, 0x00cb},
{0x228c, 0x4f49},
{0x228e, 0x425f},
{0x2290, 0x009e},
{0x2292, 0xf07f},
{0x2294, 0x000f},
{0x2296, 0x4f47},
{0x2298, 0x425f},
{0x229a, 0x009f},
{0x229c, 0xf07f},
{0x229e, 0x000f},
{0x22a0, 0xf37f},
{0x22a2, 0x5f07},
{0x22a4, 0x1107},
{0x22a6, 0x425f},
{0x22a8, 0x00b2},
{0x22aa, 0xf07f},
{0x22ac, 0x000f},
{0x22ae, 0x4f48},
{0x22b0, 0x425f},
{0x22b2, 0x00b3},
{0x22b4, 0xf07f},
{0x22b6, 0x000f},
{0x22b8, 0xf37f},
{0x22ba, 0x5f08},
{0x22bc, 0x1108},
{0x22be, 0x421f},
{0x22c0, 0x0098},
{0x22c2, 0x821f},
{0x22c4, 0x0092},
{0x22c6, 0x531f},
{0x22c8, 0x4f0c},
{0x22ca, 0x470a},
{0x22cc, 0x12b0},
{0x22ce, 0xfb7c},
{0x22d0, 0x4c82},
{0x22d2, 0x0a86},
{0x22d4, 0x9309},
{0x22d6, 0x2002},
{0x22d8, 0x4030},
{0x22da, 0xf750},
{0x22dc, 0x9318},
{0x22de, 0x2002},
{0x22e0, 0x4030},
{0x22e2, 0xf750},
{0x22e4, 0x421f},
{0x22e6, 0x00ac},
{0x22e8, 0x821f},
{0x22ea, 0x00a6},
{0x22ec, 0x531f},
{0x22ee, 0x480e},
{0x22f0, 0x533e},
{0x22f2, 0x4f0c},
{0x22f4, 0x4e0a},
{0x22f6, 0x12b0},
{0x22f8, 0xfb7c},
{0x22fa, 0x4c82},
{0x22fc, 0x0a88},
{0x22fe, 0x484f},
{0x2300, 0x5f4f},
{0x2302, 0x5f4f},
{0x2304, 0x5f4f},
{0x2306, 0x5f4f},
{0x2308, 0x474e},
{0x230a, 0x5e4e},
{0x230c, 0xde4f},
{0x230e, 0x403b},
{0x2310, 0x81e0},
{0x2312, 0xdb6f},
{0x2314, 0x4fc2},
{0x2316, 0x0a8e},
{0x2318, 0x40b2},
{0x231a, 0x0034},
{0x231c, 0x7900},
{0x231e, 0x4292},
{0x2320, 0x0092},
{0x2322, 0x0a8c},
{0x2324, 0x4292},
{0x2326, 0x0098},
{0x2328, 0x0a9e},
{0x232a, 0x4292},
{0x232c, 0x00a6},
{0x232e, 0x0a8a},
{0x2330, 0x40b2},
{0x2332, 0x0c01},
{0x2334, 0x7500},
{0x2336, 0x40b2},
{0x2338, 0x0c01},
{0x233a, 0x8268},
{0x233c, 0x40b2},
{0x233e, 0x0803},
{0x2340, 0x7502},
{0x2342, 0x40b2},
{0x2344, 0x0807},
{0x2346, 0x7504},
{0x2348, 0x40b2},
{0x234a, 0x5803},
{0x234c, 0x7506},
{0x234e, 0x40b2},
{0x2350, 0x0801},
{0x2352, 0x7508},
{0x2354, 0x40b2},
{0x2356, 0x0805},
{0x2358, 0x750a},
{0x235a, 0x40b2},
{0x235c, 0x5801},
{0x235e, 0x750c},
{0x2360, 0x40b2},
{0x2362, 0x0803},
{0x2364, 0x750e},
{0x2366, 0x40b2},
{0x2368, 0x0802},
{0x236a, 0x7510},
{0x236c, 0x40b2},
{0x236e, 0x0800},
{0x2370, 0x7512},
{0x2372, 0x403f},
{0x2374, 0x8268},
{0x2376, 0x12b0},
{0x2378, 0xe2dc},
{0x237a, 0x4392},
{0x237c, 0x7f06},
{0x237e, 0x43a2},
{0x2380, 0x7f0a},
{0x2382, 0x938b},
{0x2384, 0x0000},
{0x2386, 0x2002},
{0x2388, 0x4030},
{0x238a, 0xf71e},
{0x238c, 0x42a2},
{0x238e, 0x7f0a},
{0x2390, 0x40b2},
{0x2392, 0x000a},
{0x2394, 0x8260},
{0x2396, 0x40b2},
{0x2398, 0x01ea},
{0x239a, 0x8262},
{0x239c, 0x40b2},
{0x239e, 0x03ca},
{0x23a0, 0x8264},
{0x23a2, 0x40b2},
{0x23a4, 0x05aa},
{0x23a6, 0x8266},
{0x23a8, 0x40b2},
{0x23aa, 0xf0d2},
{0x23ac, 0x826a},
{0x23ae, 0x4382},
{0x23b0, 0x81d0},
{0x23b2, 0x9382},
{0x23b4, 0x7f0a},
{0x23b6, 0x2413},
{0x23b8, 0x430e},
{0x23ba, 0x421d},
{0x23bc, 0x826a},
{0x23be, 0x0800},
{0x23c0, 0x7f08},
{0x23c2, 0x4e0f},
{0x23c4, 0x5f0f},
{0x23c6, 0x4f92},
{0x23c8, 0x8260},
{0x23ca, 0x7f00},
{0x23cc, 0x4d82},
{0x23ce, 0x7f02},
{0x23d0, 0x531e},
{0x23d2, 0x421f},
{0x23d4, 0x7f0a},
{0x23d6, 0x9f0e},
{0x23d8, 0x2bf2},
{0x23da, 0x4e82},
{0x23dc, 0x81d0},
{0x23de, 0x407a},
{0x23e0, 0xff8b},
{0x23e2, 0x4392},
{0x23e4, 0x731c},
{0x23e6, 0x40b2},
{0x23e8, 0x8038},
{0x23ea, 0x7a00},
{0x23ec, 0x40b2},
{0x23ee, 0x0064},
{0x23f0, 0x7a02},
{0x23f2, 0x40b2},
{0x23f4, 0x0304},
{0x23f6, 0x7a08},
{0x23f8, 0x9382},
{0x23fa, 0x81de},
{0x23fc, 0x2411},
{0x23fe, 0x4382},
{0x2400, 0x81d0},
{0x2402, 0x421d},
{0x2404, 0x81d0},
{0x2406, 0x4d0e},
{0x2408, 0x5e0e},
{0x240a, 0x4e0f},
{0x240c, 0x510f},
{0x240e, 0x4e9f},
{0x2410, 0x0b00},
{0x2412, 0x0000},
{0x2414, 0x531d},
{0x2416, 0x4d82},
{0x2418, 0x81d0},
{0x241a, 0x903d},
{0x241c, 0x0016},
{0x241e, 0x2bf1},
{0x2420, 0xb3d2},
{0x2422, 0x00ce},
{0x2424, 0x2412},
{0x2426, 0x4382},
{0x2428, 0x81d0},
{0x242a, 0x421e},
{0x242c, 0x81d0},
{0x242e, 0x903e},
{0x2430, 0x0009},
{0x2432, 0x2405},
{0x2434, 0x5e0e},
{0x2436, 0x4e0f},
{0x2438, 0x510f},
{0x243a, 0x4fae},
{0x243c, 0x0b80},
{0x243e, 0x5392},
{0x2440, 0x81d0},
{0x2442, 0x90b2},
{0x2444, 0x0016},
{0x2446, 0x81d0},
{0x2448, 0x2bf0},
{0x244a, 0xb3e2},
{0x244c, 0x00ce},
{0x244e, 0x242d},
{0x2450, 0x4292},
{0x2452, 0x0126},
{0x2454, 0x0580},
{0x2456, 0x4292},
{0x2458, 0x01a8},
{0x245a, 0x0582},
{0x245c, 0x4292},
{0x245e, 0x01aa},
{0x2460, 0x0584},
{0x2462, 0x4292},
{0x2464, 0x01ac},
{0x2466, 0x0586},
{0x2468, 0x9382},
{0x246a, 0x003a},
{0x246c, 0x2542},
{0x246e, 0x90b2},
{0x2470, 0x0011},
{0x2472, 0x003a},
{0x2474, 0x2d3e},
{0x2476, 0x403e},
{0x2478, 0x012e},
{0x247a, 0x4e6f},
{0x247c, 0xf37f},
{0x247e, 0x521f},
{0x2480, 0x0126},
{0x2482, 0x4f82},
{0x2484, 0x0580},
{0x2486, 0x4e6f},
{0x2488, 0xf37f},
{0x248a, 0x521f},
{0x248c, 0x01a8},
{0x248e, 0x4f82},
{0x2490, 0x0582},
{0x2492, 0x4e6f},
{0x2494, 0xf37f},
{0x2496, 0x521f},
{0x2498, 0x01aa},
{0x249a, 0x4f82},
{0x249c, 0x0584},
{0x249e, 0x4e6f},
{0x24a0, 0xf37f},
{0x24a2, 0x521f},
{0x24a4, 0x01ac},
{0x24a6, 0x4f82},
{0x24a8, 0x0586},
{0x24aa, 0x9382},
{0x24ac, 0x81de},
{0x24ae, 0x200b},
{0x24b0, 0x0b00},
{0x24b2, 0x7302},
{0x24b4, 0x0258},
{0x24b6, 0x4382},
{0x24b8, 0x7904},
{0x24ba, 0x0900},
{0x24bc, 0x7308},
{0x24be, 0x403f},
{0x24c0, 0x8268},
{0x24c2, 0x12b0},
{0x24c4, 0xe2dc},
{0x24c6, 0x42a2},
{0x24c8, 0x81ea},
{0x24ca, 0x40b2},
{0x24cc, 0x0262},
{0x24ce, 0x81ec},
{0x24d0, 0x40b2},
{0x24d2, 0x02c4},
{0x24d4, 0x81ee},
{0x24d6, 0x40b2},
{0x24d8, 0x0532},
{0x24da, 0x81f0},
{0x24dc, 0x40b2},
{0x24de, 0x03b6},
{0x24e0, 0x81f2},
{0x24e2, 0x40b2},
{0x24e4, 0x03c4},
{0x24e6, 0x81f4},
{0x24e8, 0x40b2},
{0x24ea, 0x03de},
{0x24ec, 0x81f6},
{0x24ee, 0x40b2},
{0x24f0, 0x0596},
{0x24f2, 0x81f8},
{0x24f4, 0x40b2},
{0x24f6, 0x05c4},
{0x24f8, 0x81fa},
{0x24fa, 0x40b2},
{0x24fc, 0x0776},
{0x24fe, 0x81fc},
{0x2500, 0x9382},
{0x2502, 0x81e2},
{0x2504, 0x24e9},
{0x2506, 0x40b2},
{0x2508, 0x0289},
{0x250a, 0x81ee},
{0x250c, 0x40b2},
{0x250e, 0x04e7},
{0x2510, 0x81f0},
{0x2512, 0x12b0},
{0x2514, 0xea88},
{0x2516, 0x0900},
{0x2518, 0x7328},
{0x251a, 0x4582},
{0x251c, 0x7114},
{0x251e, 0x421f},
{0x2520, 0x7316},
{0x2522, 0xc312},
{0x2524, 0x100f},
{0x2526, 0x503f},
{0x2528, 0xff9c},
{0x252a, 0x4f82},
{0x252c, 0x7334},
{0x252e, 0x0f00},
{0x2530, 0x7302},
{0x2532, 0x4392},
{0x2534, 0x7f0c},
{0x2536, 0x4392},
{0x2538, 0x7f10},
{0x253a, 0x4392},
{0x253c, 0x770a},
{0x253e, 0x4392},
{0x2540, 0x770e},
{0x2542, 0x9392},
{0x2544, 0x7114},
{0x2546, 0x207b},
{0x2548, 0x0b00},
{0x254a, 0x7302},
{0x254c, 0x0258},
{0x254e, 0x4382},
{0x2550, 0x7904},
{0x2552, 0x0800},
{0x2554, 0x7118},
{0x2556, 0x403e},
{0x2558, 0x732a},
{0x255a, 0x4e2f},
{0x255c, 0x4f4b},
{0x255e, 0xf35b},
{0x2560, 0xd25b},
{0x2562, 0x81de},
{0x2564, 0x4e2f},
{0x2566, 0xf36f},
{0x2568, 0xdf4b},
{0x256a, 0x1246},
{0x256c, 0x1230},
{0x256e, 0x0cce},
{0x2570, 0x1230},
{0x2572, 0x0cf0},
{0x2574, 0x410f},
{0x2576, 0x503f},
{0x2578, 0x0030},
{0x257a, 0x120f},
{0x257c, 0x421c},
{0x257e, 0x0ca0},
{0x2580, 0x421d},
{0x2582, 0x0caa},
{0x2584, 0x421e},
{0x2586, 0x0cb4},
{0x2588, 0x421f},
{0x258a, 0x0cb2},
{0x258c, 0x12b0},
{0x258e, 0xf96c},
{0x2590, 0x1246},
{0x2592, 0x1230},
{0x2594, 0x0cd0},
{0x2596, 0x1230},
{0x2598, 0x0cf2},
{0x259a, 0x410f},
{0x259c, 0x503f},
{0x259e, 0x003a},
{0x25a0, 0x120f},
{0x25a2, 0x421c},
{0x25a4, 0x0ca2},
{0x25a6, 0x421d},
{0x25a8, 0x0cac},
{0x25aa, 0x421e},
{0x25ac, 0x0cb8},
{0x25ae, 0x421f},
{0x25b0, 0x0cb6},
{0x25b2, 0x12b0},
{0x25b4, 0xf96c},
{0x25b6, 0x1246},
{0x25b8, 0x1230},
{0x25ba, 0x0cd2},
{0x25bc, 0x1230},
{0x25be, 0x0cf4},
{0x25c0, 0x410f},
{0x25c2, 0x503f},
{0x25c4, 0x0044},
{0x25c6, 0x120f},
{0x25c8, 0x421c},
{0x25ca, 0x0ca4},
{0x25cc, 0x421d},
{0x25ce, 0x0cae},
{0x25d0, 0x421e},
{0x25d2, 0x0cbc},
{0x25d4, 0x421f},
{0x25d6, 0x0cba},
{0x25d8, 0x12b0},
{0x25da, 0xf96c},
{0x25dc, 0x1246},
{0x25de, 0x1230},
{0x25e0, 0x0cd4},
{0x25e2, 0x1230},
{0x25e4, 0x0cf6},
{0x25e6, 0x410f},
{0x25e8, 0x503f},
{0x25ea, 0x004e},
{0x25ec, 0x120f},
{0x25ee, 0x421c},
{0x25f0, 0x0ca6},
{0x25f2, 0x421d},
{0x25f4, 0x0cb0},
{0x25f6, 0x421e},
{0x25f8, 0x0cc0},
{0x25fa, 0x421f},
{0x25fc, 0x0cbe},
{0x25fe, 0x12b0},
{0x2600, 0xf96c},
{0x2602, 0x425f},
{0x2604, 0x0c80},
{0x2606, 0xf35f},
{0x2608, 0x5031},
{0x260a, 0x0020},
{0x260c, 0x934f},
{0x260e, 0x2008},
{0x2610, 0x4382},
{0x2612, 0x0cce},
{0x2614, 0x4382},
{0x2616, 0x0cd0},
{0x2618, 0x4382},
{0x261a, 0x0cd2},
{0x261c, 0x4382},
{0x261e, 0x0cd4},
{0x2620, 0xdb46},
{0x2622, 0x464f},
{0x2624, 0x934b},
{0x2626, 0x2001},
{0x2628, 0x5f0f},
{0x262a, 0x4f46},
{0x262c, 0x0900},
{0x262e, 0x7112},
{0x2630, 0x4a4f},
{0x2632, 0x12b0},
{0x2634, 0xfa74},
{0x2636, 0x0b00},
{0x2638, 0x7302},
{0x263a, 0x0036},
{0x263c, 0x3f82},
{0x263e, 0x0b00},
{0x2640, 0x7302},
{0x2642, 0x0036},
{0x2644, 0x4392},
{0x2646, 0x7904},
{0x2648, 0x421e},
{0x264a, 0x7100},
{0x264c, 0x9382},
{0x264e, 0x7114},
{0x2650, 0x2009},
{0x2652, 0x421f},
{0x2654, 0x00a2},
{0x2656, 0x9f0e},
{0x2658, 0x2803},
{0x265a, 0x9e82},
{0x265c, 0x00a8},
{0x265e, 0x2c02},
{0x2660, 0x4382},
{0x2662, 0x7904},
{0x2664, 0x93a2},
{0x2666, 0x7114},
{0x2668, 0x2424},
{0x266a, 0x903e},
{0x266c, 0x0038},
{0x266e, 0x2815},
{0x2670, 0x503e},
{0x2672, 0xffd8},
{0x2674, 0x4e82},
{0x2676, 0x7a04},
{0x2678, 0x43b2},
{0x267a, 0x7a06},
{0x267c, 0x9382},
{0x267e, 0x81e0},
{0x2680, 0x2408},
{0x2682, 0x9382},
{0x2684, 0x81e4},
{0x2686, 0x2411},
{0x2688, 0x421f},
{0x268a, 0x7a04},
{0x268c, 0x832f},
{0x268e, 0x4f82},
{0x2690, 0x7a06},
{0x2692, 0x4392},
{0x2694, 0x7a0a},
{0x2696, 0x0800},
{0x2698, 0x7a0a},
{0x269a, 0x4a4f},
{0x269c, 0x12b0},
{0x269e, 0xfa74},
{0x26a0, 0x930f},
{0x26a2, 0x274f},
{0x26a4, 0x4382},
{0x26a6, 0x81de},
{0x26a8, 0x3ea7},
{0x26aa, 0x421f},
{0x26ac, 0x7a04},
{0x26ae, 0x532f},
{0x26b0, 0x3fee},
{0x26b2, 0x421f},
{0x26b4, 0x00a6},
{0x26b6, 0x9f0e},
{0x26b8, 0x2803},
{0x26ba, 0x9e82},
{0x26bc, 0x00ac},
{0x26be, 0x2c02},
{0x26c0, 0x4382},
{0x26c2, 0x7904},
{0x26c4, 0x4a4f},
{0x26c6, 0xc312},
{0x26c8, 0x104f},
{0x26ca, 0xf35a},
{0x26cc, 0xe37a},
{0x26ce, 0x535a},
{0x26d0, 0xf07a},
{0x26d2, 0xffb8},
{0x26d4, 0xef4a},
{0x26d6, 0x3fc9},
{0x26d8, 0x9382},
{0x26da, 0x81e0},
{0x26dc, 0x271a},
{0x26de, 0x40b2},
{0x26e0, 0x001e},
{0x26e2, 0x81ec},
{0x26e4, 0x40b2},
{0x26e6, 0x01d6},
{0x26e8, 0x81ee},
{0x26ea, 0x40b2},
{0x26ec, 0x0205},
{0x26ee, 0x81f0},
{0x26f0, 0x3f10},
{0x26f2, 0x90b2},
{0x26f4, 0x0011},
{0x26f6, 0x003a},
{0x26f8, 0x2807},
{0x26fa, 0x90b2},
{0x26fc, 0x0080},
{0x26fe, 0x003a},
{0x2700, 0x2c03},
{0x2702, 0x403e},
{0x2704, 0x012f},
{0x2706, 0x3eb9},
{0x2708, 0x90b2},
{0x270a, 0x0080},
{0x270c, 0x003a},
{0x270e, 0x2acd},
{0x2710, 0x90b2},
{0x2712, 0x0100},
{0x2714, 0x003a},
{0x2716, 0x2ec9},
{0x2718, 0x403e},
{0x271a, 0x0130},
{0x271c, 0x3eae},
{0x271e, 0x9382},
{0x2720, 0x81e2},
{0x2722, 0x240b},
{0x2724, 0x40b2},
{0x2726, 0x000e},
{0x2728, 0x8260},
{0x272a, 0x40b2},
{0x272c, 0x028f},
{0x272e, 0x8262},
{0x2730, 0x40b2},
{0x2732, 0xf06a},
{0x2734, 0x826a},
{0x2736, 0x4030},
{0x2738, 0xf3ae},
{0x273a, 0x40b2},
{0x273c, 0x000e},
{0x273e, 0x8260},
{0x2740, 0x40b2},
{0x2742, 0x02ce},
{0x2744, 0x8262},
{0x2746, 0x40b2},
{0x2748, 0xf000},
{0x274a, 0x826a},
{0x274c, 0x4030},
{0x274e, 0xf3ae},
{0x2750, 0x421f},
{0x2752, 0x00ac},
{0x2754, 0x821f},
{0x2756, 0x00a6},
{0x2758, 0x531f},
{0x275a, 0x4f0c},
{0x275c, 0x480a},
{0x275e, 0x4030},
{0x2760, 0xf2f6},
{0x2762, 0xb3e2},
{0x2764, 0x00b4},
{0x2766, 0x2002},
{0x2768, 0x4030},
{0x276a, 0xf248},
{0x276c, 0x4315},
{0x276e, 0x4030},
{0x2770, 0xf248},
{0x2772, 0x43d2},
{0x2774, 0x0180},
{0x2776, 0x4392},
{0x2778, 0x760e},
{0x277a, 0x9382},
{0x277c, 0x760c},
{0x277e, 0x2002},
{0x2780, 0x0c64},
{0x2782, 0x3ffb},
{0x2784, 0x421f},
{0x2786, 0x760a},
{0x2788, 0x932f},
{0x278a, 0x2012},
{0x278c, 0x421b},
{0x278e, 0x018a},
{0x2790, 0x4b82},
{0x2792, 0x7600},
{0x2794, 0x12b0},
{0x2796, 0xfaec},
{0x2798, 0x903b},
{0x279a, 0x1000},
{0x279c, 0x2806},
{0x279e, 0x403f},
{0x27a0, 0x8028},
{0x27a2, 0x12b0},
{0x27a4, 0xfb00},
{0x27a6, 0x4b0d},
{0x27a8, 0x3fe6},
{0x27aa, 0x403f},
{0x27ac, 0x0028},
{0x27ae, 0x3ff9},
{0x27b0, 0x903f},
{0x27b2, 0x0003},
{0x27b4, 0x28af},
{0x27b6, 0x903f},
{0x27b8, 0x0102},
{0x27ba, 0x208a},
{0x27bc, 0x43c2},
{0x27be, 0x018c},
{0x27c0, 0x425f},
{0x27c2, 0x0186},
{0x27c4, 0x4f49},
{0x27c6, 0x93d2},
{0x27c8, 0x018f},
{0x27ca, 0x2480},
{0x27cc, 0x425f},
{0x27ce, 0x018f},
{0x27d0, 0x4f4a},
{0x27d2, 0x4b0e},
{0x27d4, 0x108e},
{0x27d6, 0xf37e},
{0x27d8, 0xc312},
{0x27da, 0x100e},
{0x27dc, 0x110e},
{0x27de, 0x110e},
{0x27e0, 0x110e},
{0x27e2, 0x4d0f},
{0x27e4, 0x108f},
{0x27e6, 0xf37f},
{0x27e8, 0xc312},
{0x27ea, 0x100f},
{0x27ec, 0x110f},
{0x27ee, 0x110f},
{0x27f0, 0x110f},
{0x27f2, 0x9f0e},
{0x27f4, 0x240d},
{0x27f6, 0x0261},
{0x27f8, 0x0000},
{0x27fa, 0x4b82},
{0x27fc, 0x7600},
{0x27fe, 0x12b0},
{0x2800, 0xfaec},
{0x2802, 0x903b},
{0x2804, 0x1000},
{0x2806, 0x285f},
{0x2808, 0x403f},
{0x280a, 0x8028},
{0x280c, 0x12b0},
{0x280e, 0xfb00},
{0x2810, 0x4382},
{0x2812, 0x81d0},
{0x2814, 0x430c},
{0x2816, 0x4c0d},
{0x2818, 0x431f},
{0x281a, 0x4c0e},
{0x281c, 0x930e},
{0x281e, 0x2403},
{0x2820, 0x5f0f},
{0x2822, 0x831e},
{0x2824, 0x23fd},
{0x2826, 0xf90f},
{0x2828, 0x2444},
{0x282a, 0x430f},
{0x282c, 0x9a0f},
{0x282e, 0x2c2c},
{0x2830, 0x4c0e},
{0x2832, 0x4b82},
{0x2834, 0x7600},
{0x2836, 0x4e82},
{0x2838, 0x7602},
{0x283a, 0x4982},
{0x283c, 0x7604},
{0x283e, 0x0264},
{0x2840, 0x0000},
{0x2842, 0x0224},
{0x2844, 0x0000},
{0x2846, 0x0264},
{0x2848, 0x0000},
{0x284a, 0x0260},
{0x284c, 0x0000},
{0x284e, 0x0268},
{0x2850, 0x0000},
{0x2852, 0x0c5a},
{0x2854, 0x02e8},
{0x2856, 0x0000},
{0x2858, 0x0cb5},
{0x285a, 0x02a8},
{0x285c, 0x0000},
{0x285e, 0x0cb5},
{0x2860, 0x0cb5},
{0x2862, 0x0cb5},
{0x2864, 0x0cb5},
{0x2866, 0x0cb5},
{0x2868, 0x0cb5},
{0x286a, 0x0cb5},
{0x286c, 0x0cb5},
{0x286e, 0x0c00},
{0x2870, 0x02e8},
{0x2872, 0x0000},
{0x2874, 0x0cb5},
{0x2876, 0x0268},
{0x2878, 0x0000},
{0x287a, 0x0c64},
{0x287c, 0x0260},
{0x287e, 0x0000},
{0x2880, 0x0c64},
{0x2882, 0x531f},
{0x2884, 0x9a0f},
{0x2886, 0x2bd5},
{0x2888, 0x4c82},
{0x288a, 0x7602},
{0x288c, 0x4b82},
{0x288e, 0x7600},
{0x2890, 0x0270},
{0x2892, 0x0000},
{0x2894, 0x0c1c},
{0x2896, 0x0270},
{0x2898, 0x0001},
{0x289a, 0x421f},
{0x289c, 0x7606},
{0x289e, 0x4f4e},
{0x28a0, 0x431f},
{0x28a2, 0x930d},
{0x28a4, 0x2403},
{0x28a6, 0x5f0f},
{0x28a8, 0x831d},
{0x28aa, 0x23fd},
{0x28ac, 0xff4e},
{0x28ae, 0xdec2},
{0x28b0, 0x018c},
{0x28b2, 0x531c},
{0x28b4, 0x923c},
{0x28b6, 0x2baf},
{0x28b8, 0x4c82},
{0x28ba, 0x81d0},
{0x28bc, 0x0260},
{0x28be, 0x0000},
{0x28c0, 0x4b0d},
{0x28c2, 0x531b},
{0x28c4, 0x3f58},
{0x28c6, 0x403f},
{0x28c8, 0x0028},
{0x28ca, 0x3fa0},
{0x28cc, 0x432a},
{0x28ce, 0x3f81},
{0x28d0, 0x903f},
{0x28d2, 0x0201},
{0x28d4, 0x2350},
{0x28d6, 0x531b},
{0x28d8, 0x4b0e},
{0x28da, 0x108e},
{0x28dc, 0xf37e},
{0x28de, 0xc312},
{0x28e0, 0x100e},
{0x28e2, 0x110e},
{0x28e4, 0x110e},
{0x28e6, 0x110e},
{0x28e8, 0x4d0f},
{0x28ea, 0x108f},
{0x28ec, 0xf37f},
{0x28ee, 0xc312},
{0x28f0, 0x100f},
{0x28f2, 0x110f},
{0x28f4, 0x110f},
{0x28f6, 0x110f},
{0x28f8, 0x9f0e},
{0x28fa, 0x2406},
{0x28fc, 0x0261},
{0x28fe, 0x0000},
{0x2900, 0x4b82},
{0x2902, 0x7600},
{0x2904, 0x12b0},
{0x2906, 0xfaec},
{0x2908, 0x4b0f},
{0x290a, 0x12b0},
{0x290c, 0xfb2a},
{0x290e, 0x4fc2},
{0x2910, 0x0188},
{0x2912, 0x3f49},
{0x2914, 0x931f},
{0x2916, 0x232f},
{0x2918, 0x421b},
{0x291a, 0x018a},
{0x291c, 0x3ff1},
{0x291e, 0x40b2},
{0x2920, 0x1807},
{0x2922, 0x0b82},
{0x2924, 0x40b2},
{0x2926, 0x3540},
{0x2928, 0x0b84},
{0x292a, 0x40b2},
{0x292c, 0x3540},
{0x292e, 0x0b86},
{0x2930, 0x4382},
{0x2932, 0x0b88},
{0x2934, 0x4382},
{0x2936, 0x0b8a},
{0x2938, 0x4382},
{0x293a, 0x0b8c},
{0x293c, 0x40b2},
{0x293e, 0x8200},
{0x2940, 0x0b8e},
{0x2942, 0x4382},
{0x2944, 0x0ba6},
{0x2946, 0x43c2},
{0x2948, 0x01a0},
{0x294a, 0x43c2},
{0x294c, 0x01a2},
{0x294e, 0x43c2},
{0x2950, 0x019d},
{0x2952, 0x40f2},
{0x2954, 0x000a},
{0x2956, 0x0f90},
{0x2958, 0x43c2},
{0x295a, 0x0f82},
{0x295c, 0x43c2},
{0x295e, 0x003d},
{0x2960, 0x4030},
{0x2962, 0xf1a2},
{0x2964, 0x5031},
{0x2966, 0x0032},
{0x2968, 0x4030},
{0x296a, 0xfb3e},
{0x296c, 0x120b},
{0x296e, 0x120a},
{0x2970, 0x1209},
{0x2972, 0x1208},
{0x2974, 0x1207},
{0x2976, 0x1206},
{0x2978, 0x1205},
{0x297a, 0x1204},
{0x297c, 0x8321},
{0x297e, 0x4039},
{0x2980, 0x0014},
{0x2982, 0x5109},
{0x2984, 0x4d07},
{0x2986, 0x4c0d},
{0x2988, 0x4926},
{0x298a, 0x4991},
{0x298c, 0x0002},
{0x298e, 0x0000},
{0x2990, 0x4915},
{0x2992, 0x0004},
{0x2994, 0x4954},
{0x2996, 0x0006},
{0x2998, 0x4f0b},
{0x299a, 0x430a},
{0x299c, 0x4e08},
{0x299e, 0x4309},
{0x29a0, 0xda08},
{0x29a2, 0xdb09},
{0x29a4, 0x570d},
{0x29a6, 0x432e},
{0x29a8, 0x421f},
{0x29aa, 0x0a86},
{0x29ac, 0x821e},
{0x29ae, 0x81e0},
{0x29b0, 0x930e},
{0x29b2, 0x2403},
{0x29b4, 0x5f0f},
{0x29b6, 0x831e},
{0x29b8, 0x23fd},
{0x29ba, 0x8f0d},
{0x29bc, 0x425f},
{0x29be, 0x0ce1},
{0x29c0, 0xf37f},
{0x29c2, 0x421e},
{0x29c4, 0x00ba},
{0x29c6, 0x4f0a},
{0x29c8, 0x4e0c},
{0x29ca, 0x12b0},
{0x29cc, 0xfb42},
{0x29ce, 0x4e0f},
{0x29d0, 0x108f},
{0x29d2, 0x4f47},
{0x29d4, 0xc312},
{0x29d6, 0x1007},
{0x29d8, 0x5808},
{0x29da, 0x6909},
{0x29dc, 0x5808},
{0x29de, 0x6909},
{0x29e0, 0x5808},
{0x29e2, 0x6909},
{0x29e4, 0x5808},
{0x29e6, 0x6909},
{0x29e8, 0x5808},
{0x29ea, 0x6909},
{0x29ec, 0x5808},
{0x29ee, 0x6909},
{0x29f0, 0x4d0e},
{0x29f2, 0x430f},
{0x29f4, 0x480c},
{0x29f6, 0x490d},
{0x29f8, 0x4e0a},
{0x29fa, 0x4f0b},
{0x29fc, 0x12b0},
{0x29fe, 0xfb98},
{0x2a00, 0x5c07},
{0x2a02, 0x474e},
{0x2a04, 0xf07e},
{0x2a06, 0x003f},
{0x2a08, 0xb392},
{0x2a0a, 0x732a},
{0x2a0c, 0x2015},
{0x2a0e, 0xb3a2},
{0x2a10, 0x732a},
{0x2a12, 0x2012},
{0x2a14, 0x9382},
{0x2a16, 0x81de},
{0x2a18, 0x200f},
{0x2a1a, 0x9344},
{0x2a1c, 0x200d},
{0x2a1e, 0x470c},
{0x2a20, 0x430d},
{0x2a22, 0x462e},
{0x2a24, 0x430f},
{0x2a26, 0x5e0c},
{0x2a28, 0x6f0d},
{0x2a2a, 0xc312},
{0x2a2c, 0x100d},
{0x2a2e, 0x100c},
{0x2a30, 0x4c07},
{0x2a32, 0x4c4e},
{0x2a34, 0xf07e},
{0x2a36, 0x003f},
{0x2a38, 0x4786},
{0x2a3a, 0x0000},
{0x2a3c, 0xb0f2},
{0x2a3e, 0x0010},
{0x2a40, 0x0c83},
{0x2a42, 0x2409},
{0x2a44, 0x4e4f},
{0x2a46, 0x5f0f},
{0x2a48, 0x5f0f},
{0x2a4a, 0x5f0f},
{0x2a4c, 0x5f0f},
{0x2a4e, 0x5f0f},
{0x2a50, 0x4f85},
{0x2a52, 0x0000},
{0x2a54, 0x3c02},
{0x2a56, 0x4385},
{0x2a58, 0x0000},
{0x2a5a, 0x412f},
{0x2a5c, 0x478f},
{0x2a5e, 0x0000},
{0x2a60, 0x5321},
{0x2a62, 0x4134},
{0x2a64, 0x4135},
{0x2a66, 0x4136},
{0x2a68, 0x4137},
{0x2a6a, 0x4138},
{0x2a6c, 0x4139},
{0x2a6e, 0x413a},
{0x2a70, 0x413b},
{0x2a72, 0x4130},
{0x2a74, 0x4f4e},
{0x2a76, 0x421f},
{0x2a78, 0x7316},
{0x2a7a, 0xc312},
{0x2a7c, 0x100f},
{0x2a7e, 0x821f},
{0x2a80, 0x81e6},
{0x2a82, 0x4f82},
{0x2a84, 0x7334},
{0x2a86, 0x0f00},
{0x2a88, 0x7302},
{0x2a8a, 0xb0b2},
{0x2a8c, 0x000f},
{0x2a8e, 0x7300},
{0x2a90, 0x200e},
{0x2a92, 0x403f},
{0x2a94, 0x0cd8},
{0x2a96, 0x43df},
{0x2a98, 0x0000},
{0x2a9a, 0x43cf},
{0x2a9c, 0x0000},
{0x2a9e, 0x4ec2},
{0x2aa0, 0x0c5a},
{0x2aa2, 0x4ec2},
{0x2aa4, 0x0c5c},
{0x2aa6, 0x4ec2},
{0x2aa8, 0x0c5e},
{0x2aaa, 0x4ec2},
{0x2aac, 0x0c60},
{0x2aae, 0x421f},
{0x2ab0, 0x7112},
{0x2ab2, 0x93a2},
{0x2ab4, 0x7114},
{0x2ab6, 0x2408},
{0x2ab8, 0x9382},
{0x2aba, 0x7112},
{0x2abc, 0x2403},
{0x2abe, 0x5292},
{0x2ac0, 0x81dc},
{0x2ac2, 0x7114},
{0x2ac4, 0x430f},
{0x2ac6, 0x4130},
{0x2ac8, 0xf31f},
{0x2aca, 0x27f6},
{0x2acc, 0x4382},
{0x2ace, 0x7f10},
{0x2ad0, 0x40b2},
{0x2ad2, 0x0003},
{0x2ad4, 0x7114},
{0x2ad6, 0x40b2},
{0x2ad8, 0x000a},
{0x2ada, 0x7334},
{0x2adc, 0x0f00},
{0x2ade, 0x7302},
{0x2ae0, 0x4392},
{0x2ae2, 0x7708},
{0x2ae4, 0x4382},
{0x2ae6, 0x770e},
{0x2ae8, 0x431f},
{0x2aea, 0x4130},
{0x2aec, 0x0260},
{0x2aee, 0x0000},
{0x2af0, 0x0c64},
{0x2af2, 0x0c64},
{0x2af4, 0x0240},
{0x2af6, 0x0000},
{0x2af8, 0x0260},
{0x2afa, 0x0000},
{0x2afc, 0x0c1e},
{0x2afe, 0x4130},
{0x2b00, 0x4f0e},
{0x2b02, 0xc312},
{0x2b04, 0x100f},
{0x2b06, 0x110f},
{0x2b08, 0xc312},
{0x2b0a, 0x100f},
{0x2b0c, 0x4f82},
{0x2b0e, 0x7600},
{0x2b10, 0xf03e},
{0x2b12, 0x0007},
{0x2b14, 0x4e82},
{0x2b16, 0x7602},
{0x2b18, 0x0262},
{0x2b1a, 0x0000},
{0x2b1c, 0x0222},
{0x2b1e, 0x0000},
{0x2b20, 0x0262},
{0x2b22, 0x0000},
{0x2b24, 0x0260},
{0x2b26, 0x0000},
{0x2b28, 0x4130},
{0x2b2a, 0x4f82},
{0x2b2c, 0x7600},
{0x2b2e, 0x0270},
{0x2b30, 0x0000},
{0x2b32, 0x0c1c},
{0x2b34, 0x0270},
{0x2b36, 0x0001},
{0x2b38, 0x421f},
{0x2b3a, 0x7606},
{0x2b3c, 0x4130},
{0x2b3e, 0xdf02},
{0x2b40, 0x3ffe},
{0x2b42, 0x430e},
{0x2b44, 0x930a},
{0x2b46, 0x2407},
{0x2b48, 0xc312},
{0x2b4a, 0x100c},
{0x2b4c, 0x2801},
{0x2b4e, 0x5a0e},
{0x2b50, 0x5a0a},
{0x2b52, 0x930c},
{0x2b54, 0x23f7},
{0x2b56, 0x4130},
{0x2b58, 0x430e},
{0x2b5a, 0x430f},
{0x2b5c, 0x3c08},
{0x2b5e, 0xc312},
{0x2b60, 0x100d},
{0x2b62, 0x100c},
{0x2b64, 0x2802},
{0x2b66, 0x5a0e},
{0x2b68, 0x6b0f},
{0x2b6a, 0x5a0a},
{0x2b6c, 0x6b0b},
{0x2b6e, 0x930c},
{0x2b70, 0x23f6},
{0x2b72, 0x930d},
{0x2b74, 0x23f4},
{0x2b76, 0x4130},
{0x2b78, 0x4030},
{0x2b7a, 0xfb58},
{0x2b7c, 0xee0e},
{0x2b7e, 0x403b},
{0x2b80, 0x0011},
{0x2b82, 0x3c05},
{0x2b84, 0x100d},
{0x2b86, 0x6e0e},
{0x2b88, 0x9a0e},
{0x2b8a, 0x2801},
{0x2b8c, 0x8a0e},
{0x2b8e, 0x6c0c},
{0x2b90, 0x6d0d},
{0x2b92, 0x831b},
{0x2b94, 0x23f7},
{0x2b96, 0x4130},
{0x2b98, 0xef0f},
{0x2b9a, 0xee0e},
{0x2b9c, 0x4039},
{0x2b9e, 0x0021},
{0x2ba0, 0x3c0a},
{0x2ba2, 0x1008},
{0x2ba4, 0x6e0e},
{0x2ba6, 0x6f0f},
{0x2ba8, 0x9b0f},
{0x2baa, 0x2805},
{0x2bac, 0x2002},
{0x2bae, 0x9a0e},
{0x2bb0, 0x2802},
{0x2bb2, 0x8a0e},
{0x2bb4, 0x7b0f},
{0x2bb6, 0x6c0c},
{0x2bb8, 0x6d0d},
{0x2bba, 0x6808},
{0x2bbc, 0x8319},
{0x2bbe, 0x23f1},
{0x2bc0, 0x4130},
{0x2bc2, 0x4130},
{0x2ffe, 0xf14c},
{0x3000, 0x01fc},
{0x3002, 0x320f},
{0x3004, 0x0001},
{0x3006, 0x01fc},
{0x3008, 0x320f},
{0x300a, 0x0001},
{0x300c, 0x01fc},
{0x300e, 0x320f},
{0x3010, 0x0001},
{0x4000, 0x2500},
{0x4002, 0xfc2c},
{0x4004, 0xc004},
{0x4006, 0x2500},
{0x4008, 0xfc2c},
{0x400a, 0xc004},
{0x400c, 0x2500},
{0x400e, 0xfc2c},
{0x4010, 0xc004},

{0x0a00, 0x0000}, //stream off
{0x0b00, 0x0000},
{0x0b02, 0x9887},
{0x0b04, 0xc540},
{0x0b06, 0xb540},
{0x0b08, 0x0085},
{0x0b0a, 0xd304},
{0x0b0c, 0x0420},
{0x0b0e, 0xc200},
{0x0b10, 0xac20},
{0x0b12, 0x0000},
{0x0b14, 0x404c},
{0x0b16, 0x6e0b},
{0x0b18, 0xf20b},
{0x0b1a, 0x0000},
{0x0b1c, 0x0000},
{0x0b1e, 0x0081},
{0x0b20, 0x0000},
{0x0b22, 0xcc80},
{0x0b24, 0x0400},
{0x0b26, 0x0001},
{0x0b28, 0x0807},
{0x0c00, 0x1190},//blc enable
{0x0c02, 0x0011},
{0x0c04, 0x0000},
{0x0c06, 0x0200},
{0x0c10, 0x0040},
{0x0c12, 0x0040},
{0x0c14, 0x0040},
{0x0c16, 0x0040},
{0x0a10, 0x4000},
{0x0c18, 0x80ff},
{0x0c60, 0x0600},
{0x0000, 0x0100}, //image orient
{0x0f0a, 0x0000},
{0x0e0a, 0x0001},
{0x004a, 0x0100},
{0x000c, 0x0022},
{0x0008, 0x0b00}, //line length pck
{0x000a, 0x0f00},
{0x005a, 0x0202},
{0x0012, 0x000e},
{0x0018, 0x0a31},
{0x0034, 0x0700},
{0x0022, 0x0008},
{0x0028, 0x0017},
{0x0024, 0x0038},
{0x002a, 0x003d},
{0x0026, 0x0040},
{0x002c, 0x07d7},
{0x002e, 0x1111},
{0x0030, 0x1111},
{0x0032, 0x1111},
{0x001a, 0x1111},
{0x001c, 0x1111},
{0x001e, 0x1111},
{0x0006, 0x0823}, //frame length lines
{0x0a22, 0x0000},
{0x0a12, 0x0a20}, //x output size
{0x0a14, 0x0798}, //y output size
{0x003e, 0x0000},
{0x0004, 0x081d}, //coarse integ time
{0x0052, 0x019c},
{0x0002, 0x0000},
{0x0a02, 0x0100},
{0x0a04, 0x014a}, //isp_en
{0x0508, 0x0100},
{0x0046, 0x0000},
{0x003a, 0x0000}, //analog gain 1x
{0x0036, 0x0070},
{0x0038, 0x7000},
{0x004c, 0x7070},
{0x0122, 0x0301},
{0x0804, 0x0002},
{0x004e, 0x0300},
{0x0a1a, 0x0800},
{0x0126, 0x0100}, //Dgain_gr
{0x0128, 0x0100}, //Dgain_gb
{0x012a, 0x0100}, //Dgain_r
{0x012c, 0x0100}, //Dgain_b
{0x012e, 0x0203},
{0x0130, 0x0600},
{0x090c, 0x0A38},
{0x090e, 0x002a},
//===============================================
//             mipi 2 lane 880Mbps
//===============================================
{0x0902, 0x431a},
{0x0914, 0xc10b},
{0x0916, 0x071f},
{0x091c, 0x0e09},
{0x0918, 0x0307},
{0x091a, 0x0c0c},
{0x091e, 0x0a00},
{0x0a00, 0x0100}, //stream on
};

static const SENSOR_REG_T hi553_preview_setting[] = {
//Sensor Information////////////////////////////
//Sensor	  : Hi-553
//Date		  : 2015-09-05
//Customer        : LGE
//Image size	  : 1296x972
//MCLK		  : 24MHz
//MIPI speed(Mbps): 440Mbps x 2Lane
//Frame Length	  : 2049
//Line Length 	  : 2816
//Max Fps 	  : 30.5fps
//Pixel order 	  : Green 1st (=GB)
//X/Y-flip	  : X-flip
//BLC offset	  : 64code
////////////////////////////////////////////////

//{0x0a00, 0x0000}, //stream on
{0x0b14, 0x404c},
{0x0b16, 0x6e0b},
{0x0b18, 0xf24b},
{0x004a, 0x0100},
{0x000c, 0x0022},
{0x0008, 0x0b00},
{0x005a, 0x0204},
{0x0012, 0x000e},
{0x0018, 0x0a31},
{0x0024, 0x0038},
{0x002a, 0x003d},
{0x0026, 0x0040},
{0x002c, 0x07d7},
{0x002e, 0x1111},
{0x0030, 0x1111},
{0x0032, 0x3311},
{0x001a, 0x1111},
{0x001c, 0x1111},
{0x001e, 0x1111},
{0x0006, 0x0801}, //frame length lines
{0x0a22, 0x0000},
{0x0a12, 0x0510}, //x output size
{0x0a14, 0x03cc}, //y output size
{0x003e, 0x0000},
{0x0004, 0x07fb}, //coarse int. time
{0x0a04, 0x016a}, //isp_en
{0x0a1a, 0x0800},
{0x090c, 0x0514},
{0x090e, 0x0018},
//===============================================
//             mipi 2 lane 440Mbps
//===============================================
{0x0902, 0x431a},
{0x0914, 0xc106},
{0x0916, 0x040f},
{0x091c, 0x0e05},
{0x0918, 0x0304},
{0x091a, 0x0609},
{0x091e, 0x0300},
//{0x0a00, 0x0100}, //stream on
};

static const SENSOR_REG_T hi553_snapshot_setting[] = {
//Sensor Information////////////////////////////
//Sensor	  : Hi-553
//Date		  : 2015-09-05
//Customer        : LGE
//Image size	  : 2592x1944
//MCLK		  : 24MHz
//MIPI speed(Mbps): 880Mbps x 2Lane
//Frame Length	  : 2049
//Line Length 	  : 2816
//Max Fps 	  : 30.5fps
//Pixel order 	  : Green 1st (=GB)
//X/Y-flip	  : X-flip
//BLC offset	  : 64code
////////////////////////////////////////////////

//{0x0a00, 0x0000}, //stream on
{0x0b14, 0x404c},
{0x0b16, 0x6e0b},
{0x0b18, 0xf20b},
{0x004a, 0x0100},
{0x000c, 0x0022},
{0x0008, 0x0b00},
{0x005a, 0x0202},
{0x0012, 0x000e},
{0x0018, 0x0a31},
{0x0024, 0x0038},
{0x002a, 0x003d},
{0x0026, 0x0040},
{0x002c, 0x07d7},
{0x002e, 0x1111},
{0x0030, 0x1111},
{0x0032, 0x1111},
{0x001a, 0x1111},
{0x001c, 0x1111},
{0x001e, 0x1111},
{0x0006, 0x0801}, //frame length lines
{0x0a22, 0x0000},
{0x0a12, 0x0a20}, //x output size
{0x0a14, 0x0798}, //y output size
{0x003e, 0x0000},
{0x0004, 0x07fb}, //coarse int. time
{0x0a04, 0x014a}, //isp_en
{0x0a1a, 0x0800},
{0x090c, 0x0a38},
{0x090e, 0x002a},
//===============================================
//             mipi 2 lane 880Mbps
//===============================================
{0x0902, 0x431a},
{0x0914, 0xc10b},
{0x0916, 0x071f},
{0x091c, 0x0e09},
{0x0918, 0x0307},
{0x091a, 0x0c0c},
{0x091e, 0x0a00},
//{0x0a00, 0x0100}, //stream on
};

static SENSOR_REG_TAB_INFO_T s_hi553_resolution_tab_raw[SENSOR_MODE_MAX] = {
	{ADDR_AND_LEN_OF_ARRAY(hi553_init_setting), 0, 0, EX_MCLK,
	 SENSOR_IMAGE_FORMAT_RAW},
//	{ADDR_AND_LEN_OF_ARRAY(hi553_preview_setting),
//	 PREVIEW_WIDTH, PREVIEW_HEIGHT, EX_MCLK,
//	 SENSOR_IMAGE_FORMAT_RAW},
	{ADDR_AND_LEN_OF_ARRAY(hi553_snapshot_setting),
	 SNAPSHOT_WIDTH, SNAPSHOT_HEIGHT, EX_MCLK,
	 SENSOR_IMAGE_FORMAT_RAW},
};

static SENSOR_TRIM_T s_hi553_resolution_trim_tab[SENSOR_MODE_MAX] = {
	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},
//	{0, 0, PREVIEW_WIDTH, PREVIEW_HEIGHT,
//	 PREVIEW_LINE_TIME, PREVIEW_MIPI_PER_LANE_BPS, PREVIEW_FRAME_LENGTH,
//	 {0, 0, PREVIEW_WIDTH, PREVIEW_HEIGHT}},
	{0, 0, SNAPSHOT_WIDTH, SNAPSHOT_HEIGHT,
	 SNAPSHOT_LINE_TIME, SNAPSHOT_MIPI_PER_LANE_BPS, SNAPSHOT_FRAME_LENGTH,
	 {0, 0, SNAPSHOT_WIDTH, SNAPSHOT_HEIGHT}},
};

static const SENSOR_REG_T s_hi553_preview_size_video_tab[SENSOR_VIDEO_MODE_MAX][1] = {
	/*video mode 0: ?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 1:?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 2:?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 3:?fps */
	{
	 {0xffff, 0xff}
	 }
};

static const SENSOR_REG_T s_hi553_capture_size_video_tab[SENSOR_VIDEO_MODE_MAX][1] = {
	/*video mode 0: ?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 1:?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 2:?fps */
	{
	 {0xffff, 0xff}
	 },
	/* video mode 3:?fps */
	{
	 {0xffff, 0xff}
	 }
};

static SENSOR_VIDEO_INFO_T s_hi553_video_info[SENSOR_MODE_MAX] = {
	{{{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, PNULL},
//	{{{30, 30, 270, 90}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
//	 (SENSOR_REG_T **) s_hi553_preview_size_video_tab},
	{{{2, 5, 338, 1000}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
	 (SENSOR_REG_T **) s_hi553_capture_size_video_tab},
};

/*==============================================================================
 * Description:
 * set video mode
 *
 *============================================================================*/
static cmr_uint hi553_set_video_mode(cmr_uint param)
{
	SENSOR_REG_T_PTR sensor_reg_ptr;
	uint16_t i = 0x00;
	cmr_u32 mode;

	if (param >= SENSOR_VIDEO_MODE_MAX)
		return 0;

	if (SENSOR_SUCCESS != Sensor_GetMode(&mode)) {
		SENSOR_PRINT("fail.");
		return SENSOR_FAIL;
	}

	if (PNULL == s_hi553_video_info[mode].setting_ptr) {
		SENSOR_PRINT("fail.");
		return SENSOR_FAIL;
	}

	sensor_reg_ptr = (SENSOR_REG_T_PTR) & s_hi553_video_info[mode].setting_ptr[param];
	if (PNULL == sensor_reg_ptr) {
		SENSOR_PRINT("fail.");
		return SENSOR_FAIL;
	}

	for (i = 0x00; (0xffff != sensor_reg_ptr[i].reg_addr)
	     || (0xff != sensor_reg_ptr[i].reg_value); i++) {
		Sensor_WriteReg(sensor_reg_ptr[i].reg_addr, sensor_reg_ptr[i].reg_value);
	}

	return 0;
}

/*==============================================================================
 * Description:
 * sensor all info
 * please modify this variable acording your spec
 *============================================================================*/
SENSOR_INFO_T g_hi553_mipi_raw_info = {
	/* salve i2c write address */
	(I2C_SLAVE_ADDR_W >> 1),
	/* salve i2c read address */
	(I2C_SLAVE_ADDR_R >> 1),
	/*bit0: 0: i2c register value is 8 bit, 1: i2c register value is 16 bit */
	SENSOR_I2C_REG_16BIT | SENSOR_I2C_VAL_16BIT | SENSOR_I2C_FREQ_400,
	/* bit2: 0:negative; 1:positive -> polarily of horizontal synchronization signal
	 * bit4: 0:negative; 1:positive -> polarily of vertical synchronization signal
	 * other bit: reseved
	 */
	SENSOR_HW_SIGNAL_PCLK_P | SENSOR_HW_SIGNAL_VSYNC_P | SENSOR_HW_SIGNAL_HSYNC_P,
	/* preview mode */
	SENSOR_ENVIROMENT_NORMAL | SENSOR_ENVIROMENT_NIGHT,
	/* image effect */
	SENSOR_IMAGE_EFFECT_NORMAL |
	    SENSOR_IMAGE_EFFECT_BLACKWHITE |
	    SENSOR_IMAGE_EFFECT_RED |
	    SENSOR_IMAGE_EFFECT_GREEN | SENSOR_IMAGE_EFFECT_BLUE | SENSOR_IMAGE_EFFECT_YELLOW |
	    SENSOR_IMAGE_EFFECT_NEGATIVE | SENSOR_IMAGE_EFFECT_CANVAS,

	/* while balance mode */
	0,
	/* bit[0:7]: count of step in brightness, contrast, sharpness, saturation
	 * bit[8:31] reseved
	 */
	7,
	/* reset pulse level */
	SENSOR_LOW_PULSE_RESET,
	/* reset pulse width(ms) */
	50,
	/* 1: high level valid; 0: low level valid */
	SENSOR_LOW_LEVEL_PWDN,
	/* count of identify code */
	1,
	/* supply two code to identify sensor.
	 * for Example: index = 0-> Device id, index = 1 -> version id
	 * customer could ignore it.
	 */
	{{hi553_PID_ADDR, hi553_PID_VALUE}
	 ,
	 {hi553_VER_ADDR, hi553_VER_VALUE}
	 }
	,
	/* voltage of avdd */
	SENSOR_AVDD_2800MV,
	/* max width of source image */
	SNAPSHOT_WIDTH,
	/* max height of source image */
	SNAPSHOT_HEIGHT,
	/* name of sensor */
	SENSOR_NAME,
	/* define in SENSOR_IMAGE_FORMAT_E enum,SENSOR_IMAGE_FORMAT_MAX
	 * if set to SENSOR_IMAGE_FORMAT_MAX here,
	 * image format depent on SENSOR_REG_TAB_INFO_T
	 */
	SENSOR_IMAGE_FORMAT_RAW,
	/*  pattern of input image form sensor */
	SENSOR_IMAGE_PATTERN_RAWRGB_GB,
	/* point to resolution table information structure */
	s_hi553_resolution_tab_raw,
	/* point to ioctl function table */
	&s_hi553_ioctl_func_tab,
	/* information and table about Rawrgb sensor */
	&s_hi553_mipi_raw_info_ptr,
	/* extend information about sensor
	 * like &g_hi553_ext_info
	 */
	NULL,
	/* voltage of iovdd */
	SENSOR_AVDD_1800MV,
	/* voltage of dvdd */
	SENSOR_AVDD_1200MV,
	/* skip frame num before preview */
	3,
	/* skip frame num before capture */
	1,
	/* deci frame num during preview */
	0,
	/* deci frame num during video preview */
	0,
	0,
	0,
	0,
	0,
	0,
	{SENSOR_INTERFACE_TYPE_CSI2, LANE_NUM, RAW_BITS, 0}
	,
	0,
	/* skip frame num while change setting */
	3,
	/* horizontal  view angle*/
	65,
	/* vertical view angle*/
	60
};

/*==============================================================================
 * Description:
 * get default frame length
 *
 *============================================================================*/
static cmr_uint hi553_get_default_frame_length(cmr_uint mode)
{
	return s_hi553_resolution_trim_tab[mode].frame_line;
}

/*==============================================================================
 * Description:
 * write group-hold on to sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static void hi553_group_hold_on(void)
{
	SENSOR_PRINT("E");

	Sensor_WriteReg(0x0046, 0x01);
}

/*==============================================================================
 * Description:
 * write group-hold off to sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static void hi553_group_hold_off(void)
{
	SENSOR_PRINT("E");

	Sensor_WriteReg(0x0046, 0x00);
}


/*==============================================================================
 * Description:
 * read gain from sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static uint16_t hi553_read_gain(void)
{
	uint16_t gain = 0;

	gain = Sensor_ReadReg(0x003a);
	return gain;
}

/*==============================================================================
 * Description:
 * write gain to sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static void hi553_write_gain(cmr_uint gain)
{
	if (SENSOR_MAX_GAIN < gain)
			gain = SENSOR_MAX_GAIN;

	Sensor_WriteReg(0x003a, ((((gain-16)/16)<<4)+gain%16));

	hi553_group_hold_off();

}

/*==============================================================================
 * Description:
 * read frame length from sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static uint16_t hi553_read_frame_length(void)
{
	uint16_t frame_len = 0;

	frame_len = Sensor_ReadReg(0x0006);

	return frame_len;
}

/*==============================================================================
 * Description:
 * write frame length to sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static void hi553_write_frame_length(cmr_uint frame_len)
{
	Sensor_WriteReg(0x0006, frame_len);
}

/*==============================================================================
 * Description:
 * read shutter from sensor registers
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_read_shutter(void)
{
	uint16_t shutter = 0;

	shutter = Sensor_ReadReg(0x0004);

	return shutter;
}

/*==============================================================================
 * Description:
 * write shutter to sensor registers
 * please pay attention to the frame length
 * please modify this function acording your spec
 *============================================================================*/
static void hi553_write_shutter(cmr_uint shutter)
{
	Sensor_WriteReg(0x0004, shutter);
}

/*==============================================================================
 * Description:
 * write exposure to sensor registers and get current shutter
 * please pay attention to the frame length
 * please don't change this function if it's necessary
 *============================================================================*/
static uint16_t hi553_update_exposure(cmr_uint shutter,cmr_uint dummy_line)
{
	cmr_uint dest_fr_len = 0;
	cmr_uint cur_fr_len = 0;
	cmr_uint fr_len = s_current_default_frame_length;

	hi553_group_hold_on();

	if (1 == SUPPORT_AUTO_FRAME_LENGTH)
		goto write_sensor_shutter;

	dest_fr_len = ((shutter + dummy_line+FRAME_OFFSET) > fr_len) ? (shutter +dummy_line+ FRAME_OFFSET) : fr_len;

	cur_fr_len = hi553_read_frame_length();

	if (shutter < SENSOR_MIN_SHUTTER)
		shutter = SENSOR_MIN_SHUTTER;

	if (dest_fr_len != cur_fr_len)
		hi553_write_frame_length(dest_fr_len);
write_sensor_shutter:
	/* write shutter to sensor registers */
	hi553_write_shutter(shutter);
	return shutter;
}

/*==============================================================================
 * Description:
 * sensor power on
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_power_on(cmr_uint power_on)
{
	SENSOR_AVDD_VAL_E dvdd_val = g_hi553_mipi_raw_info.dvdd_val;
	SENSOR_AVDD_VAL_E avdd_val = g_hi553_mipi_raw_info.avdd_val;
	SENSOR_AVDD_VAL_E iovdd_val = g_hi553_mipi_raw_info.iovdd_val;
	BOOLEAN power_down = g_hi553_mipi_raw_info.power_down_level;
	BOOLEAN reset_level = g_hi553_mipi_raw_info.reset_pulse_level;

	if (SENSOR_TRUE == power_on) {
		//set all power pin to disable status
		Sensor_PowerDown(power_down);
		Sensor_SetResetLevel(reset_level);
		usleep(10 * 1000);
		Sensor_SetIovddVoltage(iovdd_val);
		Sensor_SetAvddVoltage(avdd_val);
		Sensor_SetDvddVoltage(dvdd_val);
		Sensor_PowerDown(!power_down);
		Sensor_SetMCLK(SENSOR_DEFALUT_MCLK);
		usleep(10*1000);//>=10ms
		Sensor_SetResetLevel(!reset_level);
		usleep(100);//>=16mclk

	#ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
		Sensor_SetMonitorVoltage(SENSOR_AVDD_2800MV);
		usleep(10*1000);
		dw9714_init(2);
	#endif
	} else {
	#ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
		dw9714_deinit(0);
		Sensor_SetMonitorVoltage(SENSOR_AVDD_CLOSED);
	#endif

		Sensor_SetResetLevel(reset_level);
		usleep(10*1000);
		Sensor_SetMCLK(SENSOR_DISABLE_MCLK);
		Sensor_PowerDown(power_down);
		Sensor_SetVoltage(SENSOR_AVDD_CLOSED, SENSOR_AVDD_CLOSED, SENSOR_AVDD_CLOSED);
	}
	SENSOR_PRINT("(1:on, 0:off): %ld", power_on);
	return SENSOR_SUCCESS;
}

#ifdef FEATURE_OTP

/*==============================================================================
 * Description:
 * get  parameters from otp
 * please modify this function acording your spec
 *============================================================================*/
static int hi553_get_otp_info(struct otp_info_t *otp_info)
{
	cmr_uint ret = SENSOR_FAIL;
	uint32_t i = 0x00;

	//identify otp information
	for (i = 0; i < NUMBER_OF_ARRAY(s_hi553_raw_param_tab); i++) {
		SENSOR_PRINT("identify module_id=0x%x",s_hi553_raw_param_tab[i].param_id);

		if(PNULL!=s_hi553_raw_param_tab[i].identify_otp){
			//set default value;
			memset(otp_info, 0x00, sizeof(struct otp_info_t));

			if(SENSOR_SUCCESS==s_hi553_raw_param_tab[i].identify_otp(otp_info)){
				if (s_hi553_raw_param_tab[i].param_id== otp_info->module_id) {
					SENSOR_PRINT("identify otp sucess! module_id=0x%x",s_hi553_raw_param_tab[i].param_id);
					ret = SENSOR_SUCCESS;
					break;
				}
				else{
					SENSOR_PRINT("identify module_id failed! table module_id=0x%x, otp module_id=0x%x",s_hi553_raw_param_tab[i].param_id,otp_info->module_id);
				}
			}
			else{
				SENSOR_PRINT("identify_otp failed!");
			}
		}
		else{
			SENSOR_PRINT("no identify_otp function!");
		}
	}

	if (SENSOR_SUCCESS == ret)
		return i;
	else
		return -1;
}

/*==============================================================================
 * Description:
 * apply otp parameters to sensor register
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_apply_otp(struct otp_info_t *otp_info, int id)
{
	cmr_uint ret = SENSOR_FAIL;
	//apply otp parameters
	SENSOR_PRINT("otp_table_id = %d", id);
	if (PNULL != s_hi553_raw_param_tab[id].cfg_otp) {

		if(SENSOR_SUCCESS==s_hi553_raw_param_tab[id].cfg_otp(otp_info)){
			SENSOR_PRINT("apply otp parameters sucess! module_id=0x%x",s_hi553_raw_param_tab[id].param_id);
			ret = SENSOR_SUCCESS;
		}
		else{
			SENSOR_PRINT("update_otp failed!");
		}
	}else{
		SENSOR_PRINT("no update_otp function!");
	}

	return ret;
}

/*==============================================================================
 * Description:
 * cfg otp setting
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_cfg_otp(cmr_uint param)
{
	cmr_uint ret = SENSOR_FAIL;
	struct otp_info_t otp_info={0x00};
	int table_id = 0;
	unsigned int i=0;
	/*for otp first read unstable*/
	for(i=0; i<NUMBER_OF_ARRAY(hi553_init_setting); i++)
		Sensor_WriteReg(hi553_init_setting[i].reg_addr,hi553_init_setting[i].reg_value);

	table_id = hi553_get_otp_info(&otp_info);
	if (-1 != table_id)
		ret = hi553_apply_otp(&otp_info, table_id);

	//checking OTP apply result
	if (SENSOR_SUCCESS != ret) {//disable lsc
		Sensor_WriteReg(0xffff,0xff);
	}
	else{//enable lsc
		Sensor_WriteReg(0xffff,0xff);
	}

	return ret;
}
#endif

/*==============================================================================
 * Description:
 * identify sensor id
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_identify(cmr_uint param)
{
	uint16_t pid_value = 0x0000;
	uint16_t ver_value = 0x0000;
	cmr_uint ret_value = SENSOR_FAIL;

	SENSOR_PRINT("mipi raw identify");

	pid_value = Sensor_ReadReg(hi553_PID_ADDR);

	if (hi553_PID_VALUE == pid_value) {
		ver_value = Sensor_ReadReg(hi553_VER_ADDR);
		SENSOR_PRINT("Identify: PID = %x, VER = %x", pid_value, ver_value);
		if (hi553_VER_VALUE == ver_value) {
			Sensor_hi553_InitRawTuneInfo(&g_hi553_mipi_raw_info);
			ret_value = SENSOR_SUCCESS;
			SENSOR_PRINT_HIGH("this is hi553 sensor");
		} else {
			SENSOR_PRINT_HIGH("Identify this is %x%x sensor", pid_value, ver_value);
		}
	} else {
		SENSOR_PRINT_HIGH("identify fail, pid_value = %x", pid_value);
	}

	return ret_value;
}

/*==============================================================================
 * Description:
 * get resolution trim
 *
 *============================================================================*/
static cmr_uint hi553_get_resolution_trim_tab(cmr_uint param)
{
	return (cmr_uint) s_hi553_resolution_trim_tab;
}

/*==============================================================================
 * Description:
 * before snapshot
 * you can change this function if it's necessary
 *============================================================================*/
static cmr_uint hi553_before_snapshot(cmr_uint param)
{
	cmr_uint cap_shutter = 0;
	cmr_uint prv_shutter = 0;
	cmr_uint gain = 0;
	cmr_uint cap_gain = 0;
	cmr_uint capture_mode = param & 0xffff;
	cmr_uint preview_mode = (param >> 0x10) & 0xffff;

	cmr_uint prv_linetime = s_hi553_resolution_trim_tab[preview_mode].line_time;
	cmr_uint cap_linetime = s_hi553_resolution_trim_tab[capture_mode].line_time;

	s_current_default_frame_length = hi553_get_default_frame_length(capture_mode);
	SENSOR_PRINT("capture_mode = %ld", capture_mode);

	if (preview_mode == capture_mode) {
		cap_shutter = s_sensor_ev_info.preview_shutter;
		cap_gain = s_sensor_ev_info.preview_gain;
		goto snapshot_info;
	}

	prv_shutter = s_sensor_ev_info.preview_shutter;	//hi553_read_shutter();
	gain = s_sensor_ev_info.preview_gain;	//hi553_read_gain();

	Sensor_SetMode(capture_mode);
	Sensor_SetMode_WaitDone();

	cap_shutter = prv_shutter * prv_linetime / cap_linetime * BINNING_FACTOR;

	while (gain >= (2 * SENSOR_BASE_GAIN)) {
		if (cap_shutter * 2 > s_current_default_frame_length)
			break;
		cap_shutter = cap_shutter * 2;
		gain = gain / 2;
	}

	cap_shutter = hi553_update_exposure(cap_shutter,0);
	cap_gain = gain;
	hi553_write_gain(cap_gain);
	SENSOR_PRINT("preview_shutter = 0x%x, preview_gain = 0x%x",
		     s_sensor_ev_info.preview_shutter, s_sensor_ev_info.preview_gain);

	SENSOR_PRINT("capture_shutter = 0x%lx, capture_gain = 0x%lx", cap_shutter, cap_gain);
snapshot_info:
	s_hdr_info.capture_shutter = cap_shutter; //hi553_read_shutter();
	s_hdr_info.capture_gain = cap_gain; //hi553_read_gain();
	/* limit HDR capture min fps to 10;
	 * MaxFrameTime = 1000000*0.1us;
	 */
	s_hdr_info.capture_max_shutter = 1000000 / cap_linetime;

	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_EXPOSURETIME, cap_shutter);

	return SENSOR_SUCCESS;
}

/*==============================================================================
 * Description:
 * get the shutter from isp
 * please don't change this function unless it's necessary
 *============================================================================*/
static cmr_uint hi553_write_exposure(cmr_uint param)
{
	cmr_uint ret_value = SENSOR_SUCCESS;
	uint16_t exposure_line = 0x00;
	uint16_t dummy_line = 0x00;
	uint16_t mode = 0x00;

	exposure_line = param & 0xffff;
	dummy_line = (param >> 0x10) & 0xfff; /*for cits frame rate test*/
	mode = (param >> 0x1c) & 0x0f;

	SENSOR_PRINT("current mode = %d, exposure_line = %d, dummy_line=%d", mode, exposure_line,dummy_line);
	s_current_default_frame_length = hi553_get_default_frame_length(mode);

	s_sensor_ev_info.preview_shutter = hi553_update_exposure(exposure_line,dummy_line);

	return ret_value;
}

/*==============================================================================
 * Description:
 * get the parameter from isp to real gain
 * you mustn't change the funcion !
 *============================================================================*/
static cmr_uint isp_to_real_gain(cmr_uint param)
{
	cmr_uint real_gain = 0;


#if defined(CONFIG_CAMERA_ISP_VERSION_V3) || defined(CONFIG_CAMERA_ISP_VERSION_V4)
	real_gain=param;
#else
	real_gain = ((param & 0xf) + 16) * (((param >> 4) & 0x01) + 1);
	real_gain = real_gain * (((param >> 5) & 0x01) + 1) * (((param >> 6) & 0x01) + 1);
	real_gain = real_gain * (((param >> 7) & 0x01) + 1) * (((param >> 8) & 0x01) + 1);
	real_gain = real_gain * (((param >> 9) & 0x01) + 1) * (((param >> 10) & 0x01) + 1);
	real_gain = real_gain * (((param >> 11) & 0x01) + 1);
#endif

	return real_gain;
}

/*==============================================================================
 * Description:
 * write gain value to sensor
 * you can change this function if it's necessary
 *============================================================================*/
static cmr_uint hi553_write_gain_value(cmr_uint param)
{
	cmr_uint ret_value = SENSOR_SUCCESS;
	cmr_uint real_gain = 0;

	real_gain = isp_to_real_gain(param);

	real_gain = real_gain * SENSOR_BASE_GAIN / ISP_BASE_GAIN;
	SENSOR_PRINT("real_gain = 0x%lx", real_gain);

	s_sensor_ev_info.preview_gain = real_gain;
	hi553_write_gain(real_gain);

	return ret_value;
}

#ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
/*==============================================================================
 * Description:
 * write parameter to vcm
 * please add your VCM function to this function
 *============================================================================*/
static cmr_uint hi553_write_af(cmr_uint param)
{
	return dw9714_write_af(param);
}
#endif

/*==============================================================================
 * Description:
 * increase gain or shutter for hdr
 *
 *============================================================================*/
static void hi553_increase_hdr_exposure(uint8_t ev_multiplier)
{
	cmr_uint shutter_multiply = s_hdr_info.capture_max_shutter / s_hdr_info.capture_shutter;
	cmr_uint gain = 0;

	if (0 == shutter_multiply)
		shutter_multiply = 1;

	if (shutter_multiply >= ev_multiplier) {
		hi553_update_exposure(s_hdr_info.capture_shutter * ev_multiplier,0);
		hi553_write_gain(s_hdr_info.capture_gain);
	} else {
		gain = s_hdr_info.capture_gain * ev_multiplier / shutter_multiply;
		hi553_update_exposure(s_hdr_info.capture_shutter * shutter_multiply,0);
		hi553_write_gain(gain);
	}
}

/*==============================================================================
 * Description:
 * decrease gain or shutter for hdr
 *
 *============================================================================*/
static void hi553_decrease_hdr_exposure(uint8_t ev_divisor)
{
	uint16_t gain_multiply = 0;
	cmr_uint shutter = 0;
	gain_multiply = s_hdr_info.capture_gain / SENSOR_BASE_GAIN;

	if (gain_multiply >= ev_divisor) {
		hi553_update_exposure(s_hdr_info.capture_shutter,0);
		hi553_write_gain(s_hdr_info.capture_gain / ev_divisor);

	} else {
		shutter = s_hdr_info.capture_shutter * gain_multiply / ev_divisor;
		hi553_update_exposure(shutter,0);
		hi553_write_gain(s_hdr_info.capture_gain / gain_multiply);
	}
}

/*==============================================================================
 * Description:
 * set hdr ev
 * you can change this function if it's necessary
 *============================================================================*/
static cmr_uint hi553_set_hdr_ev(cmr_uint param)
{
	cmr_uint ret = SENSOR_SUCCESS;
	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;

	cmr_uint ev = ext_ptr->param;
	uint8_t ev_divisor, ev_multiplier;

	switch (ev) {
	case SENSOR_HDR_EV_LEVE_0:
		ev_divisor = 2;
		hi553_decrease_hdr_exposure(ev_divisor);
		break;
	case SENSOR_HDR_EV_LEVE_1:
		ev_multiplier = 2;
		hi553_increase_hdr_exposure(ev_multiplier);
		break;
	case SENSOR_HDR_EV_LEVE_2:
		ev_multiplier = 1;
		hi553_increase_hdr_exposure(ev_multiplier);
		break;
	default:
		break;
	}
	return ret;
}

/*==============================================================================
 * Description:
 * extra functoin
 * you can add functions reference SENSOR_EXT_FUNC_CMD_E which from sensor_drv_u.h
 *============================================================================*/
static cmr_uint hi553_ext_func(cmr_uint param)
{
	cmr_uint rtn = SENSOR_SUCCESS;
	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;

	SENSOR_PRINT("ext_ptr->cmd: %d", ext_ptr->cmd);
	switch (ext_ptr->cmd) {
	case SENSOR_EXT_EV:
		rtn = hi553_set_hdr_ev(param);
		break;
	default:
		break;
	}

	return rtn;
}

/*==============================================================================
 * Description:
 * mipi stream on
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_stream_on(cmr_uint param)
{
	SENSOR_PRINT("E");

	usleep(20 * 1000);
	Sensor_WriteReg(0x0a00, 0x0100);
	/*delay*/
	usleep(20 * 1000);

	return 0;
}

/*==============================================================================
 * Description:
 * mipi stream off
 * please modify this function acording your spec
 *============================================================================*/
static cmr_uint hi553_stream_off(cmr_uint param)
{
	SENSOR_PRINT("E");

	usleep(20 * 1000);
	Sensor_WriteReg(0x0a00, 0x0000);
	/*delay*/
	usleep(20*1000);

	return 0;
}

/*==============================================================================
 * Description:
 * all ioctl functoins
 * you can add functions reference SENSOR_IOCTL_FUNC_TAB_T from sensor_drv_u.h
 *
 * add ioctl functions like this:
 * .power = hi553_power_on,
 *============================================================================*/
static SENSOR_IOCTL_FUNC_TAB_T s_hi553_ioctl_func_tab = {
	.power = hi553_power_on,
	.identify = hi553_identify,
	.get_trim = hi553_get_resolution_trim_tab,
	.before_snapshort = hi553_before_snapshot,
	.write_ae_value = hi553_write_exposure,
	.write_gain_value = hi553_write_gain_value,
	#ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
	.af_enable = hi553_write_af,
	#endif
	.set_focus = hi553_ext_func,
	.set_video_mode = hi553_set_video_mode,
	.stream_on = hi553_stream_on,
	.stream_off = hi553_stream_off,
	#ifdef FEATURE_OTP
	.cfg_otp=hi553_cfg_otp,
	#endif
};
